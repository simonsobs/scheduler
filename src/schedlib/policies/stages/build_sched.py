import datetime as dt
from dataclasses import dataclass
from typing import Any, Dict
from schedlib import commands as cmd

@dataclass(frozen=True)
class BuildSched:
    policy_config: Dict[str, Any]

    def apply(self, irs, t0, t1, state):
        init_state = state
        commands = []
        for ir in irs:
            assert state.curr_time == ir.t0
            state, _, command = self._apply_ops(state, ir.operations, block=ir.block)
            assert state.curr_time == ir.t1
            commands += command
        return commands
            
    def _apply_ops(self, state, op_cfgs, block=None, az=None, alt=None):
        """
        Apply a series of operations to the current planning state, computing
        the updated state, the total duration, and resulting commands of the
        operations.

        Parameters
        ----------
        state : State
            The current planning state. It must be an object capable of tracking
            the mission's state and supporting time increment operations.
        op_cfgs : list of operation configs (dict)
            A list of operation configurations, where each configuration is a
            dictionary specifying the operation's parameters. Each operation
            configuration dict must have a 'sched_mode' key
        block : Optional[core.Block], optional
            per-block operations such as PreCal, PreObs, etc. require a block
            as part of the operation configuration.

        Returns
        -------
        new_state : State
            The new state after all operations have been applied.
        total_duration : int
            The total duration of all operations in seconds.
        commands : list of str
            A list of strings representing the commands generated by each
            operation. Commands are preconditioned by operation-specific
            indentation.

        """
        commands = []
        duration = 0

        # TODO: don't repeat

        # option to overwrite az and alt
        if (az is None or alt is None) and (block is not None):
            az, alt = block.az, block.alt

        for op_cfg_ in op_cfgs:
            op_cfg = op_cfg_.copy() # important!
            # sanity check
            for k in ['name', 'sched_mode']:
                assert k in op_cfg, f"operation config must have a '{k}' key"

            # pop some non-operation kwargs
            op_name = op_cfg.pop('name')

            indent = op_cfg.pop('indent', None)

            # not implemented now
            divider = op_cfg.pop('divider', None)

            # not needed now
            op_cfg.pop('sched_mode', None)

            # add block to the operation config if provided
            block_cfg = {'block': block} if block is not None else {}

            op_cfg = {**op_cfg, **block_cfg}  # make copy

            # apply operation
            op = cmd.make_op(op_name, **op_cfg)
            state, dur, command = op(state)

            if indent:
                command = [' '*indent+c for c in command]

            duration += dur
            state = state.increment_time(dt.timedelta(seconds=dur))
            commands += command

            if divider:
                commands += divider

        return state, duration, commands 